
主要是在XMLMapperBuilder里面是实现的

1、

  private void mapperElement(XNode parent) throws Exception {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {
        // 如果要同时使用package自动扫描和通过mapper明确指定要加载的mapper，一定要确保package自动扫描的范围不包含明确指定的mapper，
        // 否则在通过package扫描的interface的时候，尝试加载对应xml文件的loadXmlResource()的逻辑中出现判重出错，
        // 报org.apache.ibatis.binding.BindingException异常，即使xml文件中包含的内容和mapper接口中包含的语句不重复也会出错，
        // 包括加载mapper接口时自动加载的xml mapper也一样会出错。

        //mybatis提供了两类配置mapper的方法：
        // 第一类是使用package自动搜索的模式，这样指定package下所有接口都会被注册为mapper
        if ("package".equals(child.getName())) {
          String mapperPackage = child.getStringAttribute("name");
          configuration.addMappers(mapperPackage);
        } else {
          //第二种 明确指定mapper，这又可以通过resource、url或者class进行细分
          String resource = child.getStringAttribute("resource");
          String url = child.getStringAttribute("url");
          String mapperClass = child.getStringAttribute("class");
          if (resource != null && url == null && mapperClass == null) {
            ErrorContext.instance().resource(resource);
            InputStream inputStream = Resources.getResourceAsStream(resource);
            //创建XMLMapperBuilder对象
            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
            // 调用parse（）进行具体的解析
            mapperParser.parse();
          } else if (resource == null && url != null && mapperClass == null) {
            ErrorContext.instance().resource(url);
            InputStream inputStream = Resources.getUrlAsStream(url);
            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
            mapperParser.parse();
          } else if (resource == null && url == null && mapperClass != null) {
            Class<?> mapperInterface = Resources.classForName(mapperClass);
            configuration.addMapper(mapperInterface);
          } else {
            throw new BuilderException("A mapper element may only specify a url, resource or class, but not more than one.");
          }
        }
      }
    }
  }

  2、
  private void loadXmlResource() {
      // Spring may not know the real resource name so we check a flag
      // to prevent loading again a resource twice
      // this flag is set at XMLMapperBuilder#bindMapperForNamespace
      if (!configuration.isResourceLoaded("namespace:" + type.getName())) {
        String xmlResource = type.getName().replace('.', '/') + ".xml";
        InputStream inputStream = null;
        try {
          inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);
        } catch (IOException e) {
          // ignore, resource is not required
        }
        if (inputStream != null) {
          XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());
          xmlParser.parse();
        }
      }
    }

    3、 解析mapper文件XMLMapperBuilder
    （1）调用XMLMapperBuilder的parse()方法进行解析
      public void parse() {
        // 判断在configuration类中是否已经包含了该resource资源
        if (!configuration.isResourceLoaded(resource)) {
          // 解析mapper的主要逻辑在这里
          configurationElement(parser.evalNode("/mapper"));
          configuration.addLoadedResource(resource);
          bindMapperForNamespace();
        }

        parsePendingResultMaps();
        parsePendingCacheRefs();
        parsePendingStatements();
      }
     （2）解析mapper的主要逻辑在这里
       private void configurationElement(XNode context) {
          try {
          // 获取namespace属性值，即mapper文件的路径
            String namespace = context.getStringAttribute("namespace");
            if (namespace == null || namespace.equals("")) {
              throw new BuilderException("Mapper's namespace cannot be empty");
            }
            //设置namespace
            builderAssistant.setCurrentNamespace(namespace);
            cacheRefElement(context.evalNode("cache-ref"));、
            //解析缓存
            cacheElement(context.evalNode("cache"));
            // 解析parameterMap
            parameterMapElement(context.evalNodes("/mapper/parameterMap"));
            // 解析resultMap
            resultMapElements(context.evalNodes("/mapper/resultMap"));
            // 解析SQL
            sqlElement(context.evalNodes("/mapper/sql"));
            //解析CRUD
            buildStatementFromContext(context.evalNodes("select|insert|update|delete"));
          } catch (Exception e) {
            throw new BuilderException("Error parsing Mapper XML. The XML location is '" + resource + "'. Cause: " + e, e);
          }
        }
     （3）设置namespace
         检查namespace是否已经存在，如果已经存在就报错，"but found"
         不存在，就设置namespace的值
       public void setCurrentNamespace(String currentNamespace) {
          if (currentNamespace == null) {
            throw new BuilderException("The mapper element requires a namespace attribute to be specified.");
          }

          if (this.currentNamespace != null && !this.currentNamespace.equals(currentNamespace)) {
            throw new BuilderException("Wrong namespace. Expected '"
                + this.currentNamespace + "' but found '" + currentNamespace + "'.");
          }

          this.currentNamespace = currentNamespace;
        }
      （4）共用其他缓存
        private void cacheRefElement(XNode context) {
             if (context != null) {
               configuration.addCacheRef(builderAssistant.getCurrentNamespace(), context.getStringAttribute("namespace"));
               CacheRefResolver cacheRefResolver = new CacheRefResolver(builderAssistant, context.getStringAttribute("namespace"));
               try {
                 cacheRefResolver.resolveCacheRef();
               } catch (IncompleteElementException e) {
                 configuration.addIncompleteCacheRef(cacheRefResolver);
               }
             }
           }
      （5）解析缓存cache
          使用建造者模式构建缓存
        private void cacheElement(XNode context) throws Exception {
            if (context != null) {
              String type = context.getStringAttribute("type", "PERPETUAL");
              Class<? extends Cache> typeClass = typeAliasRegistry.resolveAlias(type);
              String eviction = context.getStringAttribute("eviction", "LRU");
              Class<? extends Cache> evictionClass = typeAliasRegistry.resolveAlias(eviction);
              Long flushInterval = context.getLongAttribute("flushInterval");
              Integer size = context.getIntAttribute("size");
              boolean readWrite = !context.getBooleanAttribute("readOnly", false);
              boolean blocking = context.getBooleanAttribute("blocking", false);
              Properties props = context.getChildrenAsProperties();
              builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);
            }
          }
     （6）解析参数映射parameterMap(现在基本不用)
        private void parameterMapElement(List<XNode> list) throws Exception {
            for (XNode parameterMapNode : list) {
              String id = parameterMapNode.getStringAttribute("id");
              String type = parameterMapNode.getStringAttribute("type");
              Class<?> parameterClass = resolveClass(type);
              List<XNode> parameterNodes = parameterMapNode.evalNodes("parameter");
              List<ParameterMapping> parameterMappings = new ArrayList<>();
              for (XNode parameterNode : parameterNodes) {
                String property = parameterNode.getStringAttribute("property");
                String javaType = parameterNode.getStringAttribute("javaType");
                String jdbcType = parameterNode.getStringAttribute("jdbcType");
                String resultMap = parameterNode.getStringAttribute("resultMap");
                String mode = parameterNode.getStringAttribute("mode");
                String typeHandler = parameterNode.getStringAttribute("typeHandler");
                Integer numericScale = parameterNode.getIntAttribute("numericScale");
                ParameterMode modeEnum = resolveParameterMode(mode);
                Class<?> javaTypeClass = resolveClass(javaType);
                JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);
                @SuppressWarnings("unchecked")
                Class<? extends TypeHandler<?>> typeHandlerClass = (Class<? extends TypeHandler<?>>) resolveClass(typeHandler);
                ParameterMapping parameterMapping = builderAssistant.buildParameterMapping(parameterClass, property, javaTypeClass, jdbcTypeEnum, resultMap, modeEnum, typeHandlerClass, numericScale);
                parameterMappings.add(parameterMapping);
              }
              builderAssistant.addParameterMap(id, parameterClass, parameterMappings);
            }
          }
       （7）解析结果集映射resultMap
            resultMap的例子
            <resultMap id="detailedBlogResultMap" type="Blog">
              <constructor>
                <idArg column="blog_id" javaType="int"/>
                <arg column="blog_name" javaType="string"/>
              </constructor>
              <result property="title" column="blog_title"/>
              <association property="author" javaType="Author">
                <id property="id" column="author_id"/>
                <result property="username" column="author_username"/>
                <result property="password" column="author_password"/>
                <result property="email" column="author_email"/>
                <result property="bio" column="author_bio"/>
                <result property="favouriteSection" column="author_favourite_section"/>
              </association>
              <collection property="posts" ofType="Post">
                <id property="id" column="post_id"/>
                <result property="subject" column="post_subject"/>
                <association property="author" javaType="Author"/>
                <collection property="comments" ofType="Comment">
                  <id property="id" column="comment_id"/>
                </collection>
                <collection property="tags" ofType="Tag" >
                  <id property="id" column="tag_id"/>
                </collection>
                <discriminator javaType="int" column="draft">
                  <case value="1" resultType="DraftPost"/>
                </discriminator>
              </collection>
            </resultMap>

            ofType属性，这个属性用来区分JavaBean(或字段)属性类型和集合中存储的对象类型。

           总体逻辑是先解析resultMap节点本身，然后解析子节点构造器，鉴别器discriminator，id。最后组装成真正的resultMappings。
         private void resultMapElements(List<XNode> list) throws Exception {
           for (XNode resultMapNode : list) {
             try {
               resultMapElement(resultMapNode);
             } catch (IncompleteElementException e) {
               // ignore, it will be retried
             }
           }
         }

         private ResultMap resultMapElement(XNode resultMapNode) throws Exception {
             return resultMapElement(resultMapNode, Collections.<ResultMapping> emptyList());
           }

         // 对单个的ResultMap进行解析
         // resultMap里面包含四个属性：id type extend autoMapping
         private ResultMap resultMapElement(XNode resultMapNode, List<ResultMapping> additionalResultMappings) throws Exception {
             ErrorContext.instance().activity("processing " + resultMapNode.getValueBasedIdentifier());
             String id = resultMapNode.getStringAttribute("id",
                 resultMapNode.getValueBasedIdentifier());
             String type = resultMapNode.getStringAttribute("type",
                 resultMapNode.getStringAttribute("ofType",
                     resultMapNode.getStringAttribute("resultType",
                         resultMapNode.getStringAttribute("javaType"))));
             String extend = resultMapNode.getStringAttribute("extends");
             Boolean autoMapping = resultMapNode.getBooleanAttribute("autoMapping");
             Class<?> typeClass = resolveClass(type);
             Discriminator discriminator = null;
             List<ResultMapping> resultMappings = new ArrayList<>();
             resultMappings.addAll(additionalResultMappings);
             List<XNode> resultChildren = resultMapNode.getChildren();
             //resultMap子节点里面包含了六个
             //association（复合类型）  collection（复合类型）  constructor(构造器元素 含有子节点idArg，arg) discriminator(鉴别器 含有子节点case) id  result
             for (XNode resultChild : resultChildren) {
               if ("constructor".equals(resultChild.getName())) {
                 processConstructorElement(resultChild, typeClass, resultMappings);
               } else if ("discriminator".equals(resultChild.getName())) {
                 discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);
               } else {
                 List<ResultFlag> flags = new ArrayList<>();
                 if ("id".equals(resultChild.getName())) {
                   flags.add(ResultFlag.ID);
                 }
                 resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));
               }
             }
             ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);
             try {
               return resultMapResolver.resolve();
             } catch (IncompleteElementException  e) {
               configuration.addIncompleteResultMap(resultMapResolver);
               throw e;
             }
           }
       // 对含有子节点的constructor进行解析
       private void processConstructorElement(XNode resultChild, Class<?> resultType, List<ResultMapping> resultMappings) throws Exception {
           List<XNode> argChildren = resultChild.getChildren();
           for (XNode argChild : argChildren) {
             List<ResultFlag> flags = new ArrayList<>();
             flags.add(ResultFlag.CONSTRUCTOR);
             if ("idArg".equals(argChild.getName())) {
               flags.add(ResultFlag.ID);
             }
             resultMappings.add(buildResultMappingFromContext(argChild, resultType, flags));
           }
         }
       //对含有子节点的discriminator进行解析
       private Discriminator processDiscriminatorElement(XNode context, Class<?> resultType, List<ResultMapping> resultMappings) throws Exception {
           String column = context.getStringAttribute("column");
           String javaType = context.getStringAttribute("javaType");
           String jdbcType = context.getStringAttribute("jdbcType");
           String typeHandler = context.getStringAttribute("typeHandler");
           Class<?> javaTypeClass = resolveClass(javaType);
           @SuppressWarnings("unchecked")
           Class<? extends TypeHandler<?>> typeHandlerClass = (Class<? extends TypeHandler<?>>) resolveClass(typeHandler);
           JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);
           Map<String, String> discriminatorMap = new HashMap<String, String>();
           for (XNode caseChild : context.getChildren()) {
             String value = caseChild.getStringAttribute("value");
             String resultMap = caseChild.getStringAttribute("resultMap", processNestedResultMappings(caseChild, resultMappings));
             discriminatorMap.put(value, resultMap);
           }
           return builderAssistant.buildDiscriminator(resultType, column, javaTypeClass, jdbcTypeEnum, typeHandlerClass, discriminatorMap);
         }

      （8）对resultMapping的定义

      （9）解析sql片段
       private void sqlElement(List<XNode> list) throws Exception {
          if (configuration.getDatabaseId() != null) {
            sqlElement(list, configuration.getDatabaseId());
          }
          sqlElement(list, null);
        }

        private void sqlElement(List<XNode> list, String requiredDatabaseId) throws Exception {
          for (XNode context : list) {
          // 获取databaseId,根据数据库的不同来分别执行SQL
            String databaseId = context.getStringAttribute("databaseId");
            String id = context.getStringAttribute("id");
            id = builderAssistant.applyCurrentNamespace(id, false);
            if (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) {
              sqlFragments.put(id, context);
            }
          }
        }



