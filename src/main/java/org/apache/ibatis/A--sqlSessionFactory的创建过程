
主要是在XMLConfigBuilder中实现的
public class XMLConfigBuilder extends BaseBuilder

一、SqlSessionFactoryBuilder从XML配置文件加载配置信息的过程
   1、build()方法
   （1）参数为Reader类型的
        public SqlSessionFactory build(Reader reader) {
          return build(reader, null, null);
        }
        public SqlSessionFactory build(Reader reader, String environment, Properties properties) {
            try {
            // 生成parser的过程
              XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);
            // 调用parse（）方法
              return build(parser.parse());
            } catch (Exception e) {
              throw ExceptionFactory.wrapException("Error building SqlSession.", e);
            } finally {
              ErrorContext.instance().reset();
              try {
                reader.close();
              } catch (IOException e) {
                // Intentionally ignore. Prefer previous error.
              }
            }
          }
    （2）参数为InputStream类型的
        public SqlSessionFactory build(InputStream inputStream) {
          return build(inputStream, null, null);
        }
        public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
            try {
              XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
              return build(parser.parse());
            } catch (Exception e) {
              throw ExceptionFactory.wrapException("Error building SqlSession.", e);
            } finally {
              ErrorContext.instance().reset();
              try {
                inputStream.close();
              } catch (IOException e) {
                // Intentionally ignore. Prefer previous error.
              }
            }
          }
   2、XMLConfigBuilder 解析器
      XMLConfigBuilder以及解析Mapper文件的XMLMapperBuilder都继承于BaseBuilder
     根据build()方法中的参数类型，第一个参数可以是Reader或者InputStream的

      （1）
        public XMLConfigBuilder(Reader reader, String environment, Properties props) {
          this(new XPathParser(reader, true, props, new XMLMapperEntityResolver()), environment, props);
        }
      （2）得到XPathParser示例以后
        private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {
          super(new Configuration());
          ErrorContext.instance().resource("SQL Mapper Configuration");
          this.configuration.setVariables(props);
          this.parsed = false;
          this.environment = environment;
          this.parser = parser;
        }
      （3）
       public Configuration parse() {
          if (parsed) {
            throw new BuilderException("Each XMLConfigBuilder can only be used once.");
          }
          parsed = true;
          //mybatis配置文件解析的主流程
          parseConfiguration(parser.evalNode("/configuration"));   **** 此处为重点，在接下来会着重讲解这一部分的内容
          return configuration;
        }

   3、XMLMapperEntityResolver
   4、XPathParser
     /**
     *参数说明：
     * 1、Reader reader:xml文件的路径
     * 2、boolean validation：是否对DTD进行校验
     * 3、Properties variables：属性配置
     * 4、EntityResolver entityResolver：XML实体节点解析器
     **/
     public XPathParser(Reader reader, boolean validation, Properties variables, EntityResolver entityResolver) {
         commonConstructor(validation, variables, entityResolver);
         this.document = createDocument(new InputSource(reader));
       }
   5、createDocument
    private Document createDocument(InputSource inputSource) {
       // important: this must only be called AFTER common constructor
       try {
         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
         factory.setValidating(validation);

         //设置由本工厂创建的解析器是否支持XML命名空间
         factory.setNamespaceAware(false);
         factory.setIgnoringComments(true);
         factory.setIgnoringElementContentWhitespace(false);
         //设置是否将CDATA节点转换为Text节点
         factory.setCoalescing(false);
         //设置是否展开实体引用节点，这里应该是sql片段引用的关键
         factory.setExpandEntityReferences(true);

         DocumentBuilder builder = factory.newDocumentBuilder();
         //设置解析mybatis xml文档节点的解析器,也就是上面的XMLMapperEntityResolver
         builder.setEntityResolver(entityResolver);
         builder.setErrorHandler(new ErrorHandler() {
           @Override
           public void error(SAXParseException exception) throws SAXException {
             throw exception;
           }

           @Override
           public void fatalError(SAXParseException exception) throws SAXException {
             throw exception;
           }

           @Override
           public void warning(SAXParseException exception) throws SAXException {
           }
         });
         return builder.parse(inputSource);
       } catch (Exception e) {
         throw new BuilderException("Error creating document instance.  Cause: " + e, e);
       }
     }

    二、config文件解析XMLConfigBuilderconfig.parseConfiguration
    private void parseConfiguration(XNode root) {
        try {
          //issue #117 read properties first
          propertiesElement(root.evalNode("properties"));
          Properties settings = settingsAsProperties(root.evalNode("settings"));
          loadCustomVfs(settings);
          typeAliasesElement(root.evalNode("typeAliases"));
          pluginElement(root.evalNode("plugins"));
          objectFactoryElement(root.evalNode("objectFactory"));
          objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
          reflectorFactoryElement(root.evalNode("reflectorFactory"));
          settingsElement(settings);
          // read it after objectFactory and objectWrapperFactory issue #631
          environmentsElement(root.evalNode("environments"));
          databaseIdProviderElement(root.evalNode("databaseIdProvider"));
          typeHandlerElement(root.evalNode("typeHandlers"));
          mapperElement(root.evalNode("mappers"));
        } catch (Exception e) {
          throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
        }
      }
      1、解析properties的方法：

         首先加载properties节点下的property属性，
         然后从url或resource加载配置文件，都先和configuration.variables合并，
         然后赋值到XMLConfigBuilder.parser和BaseBuilder.configuration。
         此时开始所有的属性就可以在随后的整个配置文件中使用了。

        private void propertiesElement(XNode context) throws Exception {
          if (context != null) {
            // 将property的属性name和value值保存
            Properties defaults = context.getChildrenAsProperties();
            String resource = context.getStringAttribute("resource");
            String url = context.getStringAttribute("url");
            // 不能同时包含resource和url
            if (resource != null && url != null) {
              throw new BuilderException("The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.");
            }
            if (resource != null) {
              //Resources.getResourceAsProperties(resource)生成Properties的过程
              defaults.putAll(Resources.getResourceAsProperties(resource));
            } else if (url != null) {
              defaults.putAll(Resources.getUrlAsProperties(url));
            }
            Properties vars = configuration.getVariables();
            if (vars != null) {
              defaults.putAll(vars);
            }
            parser.setVariables(defaults);
            configuration.setVariables(defaults);
          }
        }

      2、加载settings节点settingsAsProperties
        （1）首先加载settings下面的setting节点为property，然后检查所有属性,确保它们都在Configuration中已定义，而非未知的设置。

        private Properties settingsAsProperties(XNode context) {
          if (context == null) {
            return new Properties();
          }
          Properties props = context.getChildrenAsProperties();
          // Check that all settings are known to the configuration class
          MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory);
          for (Object key : props.keySet()) {
            if (!metaConfig.hasSetter(String.valueOf(key))) {
              throw new BuilderException("The setting " + key + " is not known.  Make sure you spelled it correctly (case sensitive).");
            }
          }
          return props;
        }

          <1> MetaClass（）：
          MetaClass是一个保存对象定义比如getter/setter/构造器等的元数据类,localReflectorFactory则是mybatis提供的默认反射工厂实现，
          这个ReflectorFactory主要采用了工厂类，其内部使用的Reflector采用了facade设计模式，简化反射的使用。如下所示：
          public class MetaClass {

            private ReflectorFactory reflectorFactory;
            private Reflector reflector;

            private MetaClass(Class<?> type, ReflectorFactory reflectorFactory) {
              this.reflectorFactory = reflectorFactory;
              this.reflector = reflectorFactory.findForClass(type);
            }

            public static MetaClass forClass(Class<?> type, ReflectorFactory reflectorFactory) {
              return new MetaClass(type, reflectorFactory);
            }
            ...
          }
            @Override
            public Reflector findForClass(Class<?> type) {
              if (classCacheEnabled) {
                // synchronized (type) removed see issue #461
                Reflector cached = reflectorMap.get(type);
                if (cached == null) {
                  cached = new Reflector(type);
                  reflectorMap.put(type, cached);
                }
                return cached;
              } else {
                return new Reflector(type);
              }
            }
            public Reflector(Class<?> clazz) {
              type = clazz;
              addDefaultConstructor(clazz);
              addGetMethods(clazz);
              addSetMethods(clazz);
              addFields(clazz);
              readablePropertyNames = getMethods.keySet().toArray(new String[getMethods.keySet().size()]);
              writeablePropertyNames = setMethods.keySet().toArray(new String[setMethods.keySet().size()]);
              for (String propName : readablePropertyNames) {
                caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
              }
              for (String propName : writeablePropertyNames) {
                caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);
              }
            }


        （2）得到setting之后，调用settingsElement(Properties props)将各值赋值给configuration，同时在这里有重新设置了默认值，
            所有这一点很重要，configuration中的默认值不一定是真正的默认值。
             private void settingsElement(Properties props) throws Exception {
                configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty("autoMappingBehavior", "PARTIAL")));
                configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty("autoMappingUnknownColumnBehavior", "NONE")));
                configuration.setCacheEnabled(booleanValueOf(props.getProperty("cacheEnabled"), true));
                configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty("proxyFactory")));
                configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty("lazyLoadingEnabled"), false));
                configuration.setAggressiveLazyLoading(booleanValueOf(props.getProperty("aggressiveLazyLoading"), false));
                configuration.setMultipleResultSetsEnabled(booleanValueOf(props.getProperty("multipleResultSetsEnabled"), true));
                configuration.setUseColumnLabel(booleanValueOf(props.getProperty("useColumnLabel"), true));
                configuration.setUseGeneratedKeys(booleanValueOf(props.getProperty("useGeneratedKeys"), false));
                configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty("defaultExecutorType", "SIMPLE")));
                configuration.setDefaultStatementTimeout(integerValueOf(props.getProperty("defaultStatementTimeout"), null));
                configuration.setDefaultFetchSize(integerValueOf(props.getProperty("defaultFetchSize"), null));
                configuration.setMapUnderscoreToCamelCase(booleanValueOf(props.getProperty("mapUnderscoreToCamelCase"), false));
                configuration.setSafeRowBoundsEnabled(booleanValueOf(props.getProperty("safeRowBoundsEnabled"), false));
                configuration.setLocalCacheScope(LocalCacheScope.valueOf(props.getProperty("localCacheScope", "SESSION")));
                configuration.setJdbcTypeForNull(JdbcType.valueOf(props.getProperty("jdbcTypeForNull", "OTHER")));
                configuration.setLazyLoadTriggerMethods(stringSetValueOf(props.getProperty("lazyLoadTriggerMethods"), "equals,clone,hashCode,toString"));
                configuration.setSafeResultHandlerEnabled(booleanValueOf(props.getProperty("safeResultHandlerEnabled"), true));
                configuration.setDefaultScriptingLanguage(resolveClass(props.getProperty("defaultScriptingLanguage")));
                @SuppressWarnings("unchecked")
                Class<? extends TypeHandler> typeHandler = (Class<? extends TypeHandler>)resolveClass(props.getProperty("defaultEnumTypeHandler"));
                configuration.setDefaultEnumTypeHandler(typeHandler);
                configuration.setCallSettersOnNulls(booleanValueOf(props.getProperty("callSettersOnNulls"), false));
                configuration.setUseActualParamName(booleanValueOf(props.getProperty("useActualParamName"), true));
                configuration.setReturnInstanceForEmptyRow(booleanValueOf(props.getProperty("returnInstanceForEmptyRow"), false));
                configuration.setLogPrefix(props.getProperty("logPrefix"));
                @SuppressWarnings("unchecked")
                Class<? extends Log> logImpl = (Class<? extends Log>)resolveClass(props.getProperty("logImpl"));
                configuration.setLogImpl(logImpl);
                configuration.setConfigurationFactory(resolveClass(props.getProperty("configurationFactory")));
              }
          （3）settings的配置
           <settings>
            <!--全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。默认值ture -->
            <setting name="cacheEnabled" value="true"/>

            <!--延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态。默认值false -->
            <setting name="lazyLoadingEnabled" value="true"/>

            <!--是否允许单一语句返回多结果集（需要兼容驱动）。默认值ture -->
            <setting name="multipleResultSetsEnabled" value="true"/>

            <!--使用列标签代替列名。不同的驱动在这方面会有不同的表现。默认值ture -->
            <setting name="useColumnLabel" value="true"/>

            <!--允许 JDBC 支持自动生成主键，需要驱动兼容。默认值false -->
            <setting name="useGeneratedKeys" value="false"/>

            <!--
              指定 MyBatis 应如何自动映射列到字段或属性。默认值PARTIAL  NONE, PARTIAL, FULL
              主要针对<resultMap>中没有配置<result>情形使用：
              设置为NONE，则不会映射，设置为PARTIAL，则feelingComments不会被映射，设置为FULL，则全部映射，这样就无需写<result>了
              <resultMap id="FeelingCommentResult" type="Feeling">
                  <id property="feeling_id" column="feeling_id" />
                  <!-- <result property="content" column="content" /> -->
                  <collection property="feelingComments" ofType="FeelingComment">
                      <id property="feeling_comment_id" column="feeling_comment_id" />
                      <!-- <result property="commentContent" column="commentContent" /> -->
                  </collection>
              </resultMap>
              <select id="selectFeelingComment" parameterType="map" resultMap="FeelingCommentResult">
                  select * from feeling
                      left outer join feeling_comment on feeling.feeling_id=feeling_comment.feeling_id
                     where feeling.id =#{id}
              </select>
            -->
            <setting name="autoMappingBehavior" value="PARTIAL"/>

              <!--
                指定发现自动映射目标未知列（或者未知属性类型）的行为。
                NONE: 不做任何反应（默认值）
                WARNING: 输出提醒日志 ('org.apache.ibatis.session.AutoMappingUnknownColumnBehavior' 的日志等级必须设置为 WARN)
                FAILING: 映射失败 (抛出 SqlSessionException)
              -->
            <setting name="autoMappingUnknownColumnBehavior" value="WARNING"/>

            <!--
               配置默认的执行器。
               SIMPLE :就是普通的执行器；(默认值) 在执行xxxDao.save(xxx)时，就相当于JDBC的stmt.execute(sql)；
               REUSE :执行器会重用预处理语句（prepared statements）；设为"REUSE", 在执行xxxDao.save(xxx)时，
                      相当于JDBC重用一条sql，再通过stmt传入多项参数值，然后执行stmt.executeUpdate()或stmt.executeBatch()；
               BATCH :执行器将重用语句并执行批量更新。设为"BATCH", 在执行xxxDao.save(xxx)时，
                      相当于JDBC语句的 stmt.addBatch(sql)，即仅仅是将执行SQL加入到批量计划.
             -->

            <setting name="defaultExecutorType" value="SIMPLE"/>

            <!--设置超时时间-->
            <setting name="defaultStatementTimeout" value="25"/>

            <!--为驱动的结果集获取数量（fetchSize）设置一个提示值-->
            <setting name="defaultFetchSize" value="100"/>

            <!--允许在嵌套语句中使用分页（RowBounds）。默认值false -->
            <setting name="safeRowBoundsEnabled" value="false"/>


             <!--使用驼峰命名规则。默认值false -->
            <setting name="mapUnderscoreToCamelCase" value="false"/>

            <!--MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。
                SESSION：会缓存一个会话中执行的所有查询 （默认值）
                STATEMENT：会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据  -->
            <setting name="localCacheScope" value="SESSION"/>


            <setting name="jdbcTypeForNull" value="OTHER"/>
            <setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/>
            <setting name="logImpl" value="STDOUT_LOGGING"/>
          </settings>

        3、加载自定义VFS loadCustomVfs（不懂）
           VFS主要用来加载容器内的各种资源，比如jar或者class文件。mybatis提供了2个实现 JBoss6VFS 和 DefaultVFS，
           并提供了用户扩展点，用于自定义VFS实现，加载顺序是自定义VFS实现 > 默认VFS实现 取第一个加载成功的，
           默认情况下会先加载JBoss6VFS，如果classpath下找不到jboss的vfs实现才会加载默认VFS实现
           private void loadCustomVfs(Properties props) throws ClassNotFoundException {
               String value = props.getProperty("vfsImpl");
               if (value != null) {
                 String[] clazzes = value.split(",");
                 for (String clazz : clazzes) {
                   if (!clazz.isEmpty()) {
                     @SuppressWarnings("unchecked")
                     Class<? extends VFS> vfsImpl = (Class<? extends VFS>)Resources.classForName(clazz);
                     configuration.setVfsImpl(vfsImpl);
                   }
                 }
               }
             }
        4、解析类型别名typeAliasesElement
         private void typeAliasesElement(XNode parent) {
             if (parent != null) {
               // 提供两种别名设置的方法package和typeAlias
               //1、具体类的别名 2、包的别名设置
               // 所有的别名，无论是内置的还是自定义的，都一开始被保存在configuration.typeAliasRegistry中
               for (XNode child : parent.getChildren()) {
                 if ("package".equals(child.getName())) {
                   String typeAliasPackage = child.getStringAttribute("name");
                   configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
                 } else {
                   String alias = child.getStringAttribute("alias");
                   String type = child.getStringAttribute("type");
                   try {
                     Class<?> clazz = Resources.classForName(type);
                     if (alias == null) {
                       typeAliasRegistry.registerAlias(clazz);
                     } else {
                       typeAliasRegistry.registerAlias(alias, clazz);
                     }
                   } catch (ClassNotFoundException e) {
                     throw new BuilderException("Error registering typeAlias for '" + alias + "'. Cause: " + e, e);
                   }
                 }
               }
             }
           }

       5、加载插件pluginElement
          private void pluginElement(XNode parent) throws Exception {
             if (parent != null) {
               for (XNode child : parent.getChildren()) {
                 String interceptor = child.getStringAttribute("interceptor");
                 Properties properties = child.getChildrenAsProperties();
                 //将interceptor指定的名称解析为Interceptor类型
                 Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();
                 interceptorInstance.setProperties(properties);
                 configuration.addInterceptor(interceptorInstance);
               }
             }
           }
       6、加载对象工厂objectFactoryElement
         MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。
         默认的对象工厂DefaultObjectFactory做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化
       private void objectFactoryElement(XNode context) throws Exception {
           if (context != null) {
             String type = context.getStringAttribute("type");
             Properties properties = context.getChildrenAsProperties();
             ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance();
             factory.setProperties(properties);
             configuration.setObjectFactory(factory);
           }
         }
       7、创建对象包装器工厂objectWrapperFactoryElement
       对象包装器工厂主要用来包装返回result对象，比如说可以用来设置某些敏感字段脱敏或者加密等。
       默认对象包装器工厂是DefaultObjectWrapperFactory，也就是不使用包装器工厂。
        private void objectWrapperFactoryElement(XNode context) throws Exception {
           if (context != null) {
             String type = context.getStringAttribute("type");
             ObjectWrapperFactory factory = (ObjectWrapperFactory) resolveClass(type).newInstance();
             configuration.setObjectWrapperFactory(factory);
           }
         }
       8、加载反射工厂reflectorFactoryElement
       因为加载配置文件中的各种插件类等等，为了提供更好的灵活性，mybatis支持用户自定义反射工厂，不过总体来说，用的不多，要实现反射工厂，
       只要实现ReflectorFactory接口即可。默认的反射工厂是DefaultReflectorFactory。
       private void reflectorFactoryElement(XNode context) throws Exception {
           if (context != null) {
              String type = context.getStringAttribute("type");
              ReflectorFactory factory = (ReflectorFactory) resolveClass(type).newInstance();
              configuration.setReflectorFactory(factory);
           }
         }
       9、加载环境配置environmentsElement
       private void environmentsElement(XNode context) throws Exception {
           if (context != null) {
             // 如果environment存在就设置默认的值"default"
             if (environment == null) {
               environment = context.getStringAttribute("default");
             }
             for (XNode child : context.getChildren()) {
               String id = child.getStringAttribute("id");
               //查找匹配的environment
               if (isSpecifiedEnvironment(id)) {
                 // 事务配置并创建事务工厂
                 TransactionFactory txFactory = transactionManagerElement(child.evalNode("transactionManager"));
                 // 数据源配置加载并实例化数据源, 数据源是必备的
                 DataSourceFactory dsFactory = dataSourceElement(child.evalNode("dataSource"));
                 DataSource dataSource = dsFactory.getDataSource();
                 // 创建Environment.Builder
                 Environment.Builder environmentBuilder = new Environment.Builder(id)
                     .transactionFactory(txFactory)
                     .dataSource(dataSource);
                 configuration.setEnvironment(environmentBuilder.build());
               }
             }
           }
         }
       10、数据库厂商标识加载databaseIdProviderElement
       private void databaseIdProviderElement(XNode context) throws Exception {
           DatabaseIdProvider databaseIdProvider = null;
           if (context != null) {
             String type = context.getStringAttribute("type");
             // awful patch to keep backward compatibility
             if ("VENDOR".equals(type)) {
                 type = "DB_VENDOR";
             }
             Properties properties = context.getChildrenAsProperties();
             databaseIdProvider = (DatabaseIdProvider) resolveClass(type).newInstance();
             databaseIdProvider.setProperties(properties);
           }
           Environment environment = configuration.getEnvironment();
           if (environment != null && databaseIdProvider != null) {
             String databaseId = databaseIdProvider.getDatabaseId(environment.getDataSource());
             configuration.setDatabaseId(databaseId);
           }
         }
        11、加载类型处理器typeHandlerElement
        private void typeHandlerElement(XNode parent) throws Exception {
            if (parent != null) {
              for (XNode child : parent.getChildren()) {
                if ("package".equals(child.getName())) {
                  String typeHandlerPackage = child.getStringAttribute("name");
                  typeHandlerRegistry.register(typeHandlerPackage);
                } else {
                  String javaTypeName = child.getStringAttribute("javaType");
                  String jdbcTypeName = child.getStringAttribute("jdbcType");
                  String handlerTypeName = child.getStringAttribute("handler");
                  Class<?> javaTypeClass = resolveClass(javaTypeName);
                  JdbcType jdbcType = resolveJdbcType(jdbcTypeName);
                  Class<?> typeHandlerClass = resolveClass(handlerTypeName);
                  if (javaTypeClass != null) {
                    if (jdbcType == null) {
                      typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);
                    } else {
                      typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);
                    }
                  } else {
                    typeHandlerRegistry.register(typeHandlerClass);
                  }
                }
              }
            }
          }
        12、加载mapper文件mapperElement
        （1）源码
        注意：如果要同时使用package自动扫描和通过mapper明确指定要加载的mapper，则必须先声明mapper，然后声明package，否则DTD校验会失败
         private void mapperElement(XNode parent) throws Exception {
             if (parent != null) {
               for (XNode child : parent.getChildren()) {
                 // 如果要同时使用package自动扫描和通过mapper明确指定要加载的mapper，一定要确保package自动扫描的范围不包含明确指定的mapper，
                 // 否则在通过package扫描的interface的时候，尝试加载对应xml文件的loadXmlResource()的逻辑中出现判重出错，
                 // 报org.apache.ibatis.binding.BindingException异常，即使xml文件中包含的内容和mapper接口中包含的语句不重复也会出错，
                 // 包括加载mapper接口时自动加载的xml mapper也一样会出错。

                 //mybatis提供了两类配置mapper的方法：
                 // 第一类是使用package自动搜索的模式，这样指定package下所有接口都会被注册为mapper
                 if ("package".equals(child.getName())) {
                   String mapperPackage = child.getStringAttribute("name");
                   configuration.addMappers(mapperPackage);
                 } else {
                   //第二种 明确指定mapper，这又可以通过resource、url或者class进行细分
                   String resource = child.getStringAttribute("resource");
                   String url = child.getStringAttribute("url");
                   String mapperClass = child.getStringAttribute("class");
                   if (resource != null && url == null && mapperClass == null) {
                     ErrorContext.instance().resource(resource);
                     InputStream inputStream = Resources.getResourceAsStream(resource);
                     XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
                     mapperParser.parse();
                   } else if (resource == null && url != null && mapperClass == null) {
                     ErrorContext.instance().resource(url);
                     InputStream inputStream = Resources.getUrlAsStream(url);
                     XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
                     mapperParser.parse();
                   } else if (resource == null && url == null && mapperClass != null) {
                     Class<?> mapperInterface = Resources.classForName(mapperClass);
                     configuration.addMapper(mapperInterface);
                   } else {
                     throw new BuilderException("A mapper element may only specify a url, resource or class, but not more than one.");
                   }
                 }
               }
             }
           }
         （2）mapper引用的四种方式
          <!-- 使用相对于类路径的资源引用 -->
          <mappers>
            <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
            <mapper resource="org/mybatis/builder/BlogMapper.xml"/>
            <mapper resource="org/mybatis/builder/PostMapper.xml"/>
          </mappers>
          <!-- 使用完全限定资源定位符（URL） -->
          <mappers>
            <mapper url="file:///var/mappers/AuthorMapper.xml"/>
            <mapper url="file:///var/mappers/BlogMapper.xml"/>
            <mapper url="file:///var/ßmappers/PostMapper.xml"/>
          </mappers>
          <!-- 使用映射器接口实现类的完全限定类名 -->
          <mappers>
            <mapper class="org.mybatis.builder.AuthorMapper"/>
            <mapper class="org.mybatis.builder.BlogMapper"/>
            <mapper class="org.mybatis.builder.PostMapper"/>
          </mappers>
          <!-- 将包内的映射器接口实现全部注册为映射器 -->
          <mappers>
            <package name="org.mybatis.builder"/>
          </mappers>







